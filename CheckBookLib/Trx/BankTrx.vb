Option Strict On
Option Explicit On

''' <summary>
''' A BaseTrx subclass representing a transaction that exists somewhere in the real
''' world, like a credit card company or a bank. The actual amount of the transaction
''' is represented by a collection of Split objects. Each BankTrx has at least
''' one TrxSplit object.
''' </summary>

Public Class BankTrx
    Inherits BaseTrx

    'Unique key identifying an external transaction imported to create this BankTrx.
    'Used for matching new imported BankTrx against prior imports, to avoid duplicates.
    Private mstrImportKey As String
    'True iff any split with a budget key was not matched to a BudgetTrx,
    'and the BankTrx date was not before the earliest budget in the register.
    Private mblnAnyUnmatchedBudget As Boolean
    'BaseTrx amount may be different from a matching BankTrx
    'by this amount, either positive or negative.
    Private mcurNormalMatchRange As Decimal
    'Collection of TrxSplit objects belonging to this BaseTrx.
    Private mcolSplits As List(Of TrxSplit)

    Public Sub New(ByVal objReg_ As Register)
        MyBase.New(objReg_)
    End Sub

    '$Description Initialize a new normal BaseTrx object. Normally followed by calls to
    '   AddSplit(), and finally either Register.NewLoadEnd() or Register.NewAddEnd().
    '$Param objReg The Register this BaseTrx will be added to. May be Nothing, in which case
    '   the caller is responsible for calling ClearFirstAffected() for the appropriate
    '   Register before NewAddEnd().

    Public Sub NewStartNormal(ByVal blnWillAddToRegister As Boolean, ByVal strNumber_ As String, ByVal datDate_ As Date,
                              ByVal strDescription_ As String, ByVal strMemo_ As String, ByVal lngStatus_ As TrxStatus,
                              ByVal blnFake_ As Boolean, ByVal curNormalMatchRange_ As Decimal,
                              ByVal blnAwaitingReview_ As Boolean, ByVal blnAutoGenerated_ As Boolean,
                              ByVal intRepeatSeq_ As Integer, ByVal strImportKey_ As String,
                              ByVal strRepeatKey_ As String)

        If blnWillAddToRegister Then
            RegisterInternal.ClearFirstAffected()
        End If

        'NOTE: NewStartNormal() and NewEmptyNormal() must set the same properties.
        NumberInternal = strNumber_
        TrxDateInternal = datDate_
        DescriptionInternal = strDescription_
        MemoInternal = strMemo_
        StatusInternal = lngStatus_
        IsFakeInternal = blnFake_
        mcurNormalMatchRange = curNormalMatchRange_
        IsAwaitingReviewInternal = blnAwaitingReview_
        IsAutoGeneratedInternal = blnAutoGenerated_
        RepeatSeqInternal = intRepeatSeq_
        mstrImportKey = strImportKey_
        RepeatKeyInternal = strRepeatKey_

        ClearNormal()

        RaiseErrorOnBadData("NewStartNormal")

    End Sub

    Public Sub NewStartNormal(ByVal blnWillAddToRegister As Boolean, ByVal strNumber_ As String, ByVal datDate_ As Date,
                              ByVal strDescription_ As String, ByVal strMemo_ As String, ByVal lngStatus_ As TrxStatus,
                              ByVal objData As TrxGenImportData)
        With objData
            NewStartNormal(blnWillAddToRegister, strNumber_, datDate_, strDescription_, strMemo_, lngStatus_,
                .IsFake, .NormalMatchRange, .IsAwaitingReview, .IsAutoGenerated,
                .RepeatSeq, .ImportKey, .RepeatKey)
        End With
    End Sub

    Public Sub NewStartNormal(ByVal blnWillAddToRegister As Boolean, ByVal objTrx As BankTrx)
        With objTrx
            NewStartNormal(blnWillAddToRegister, .Number, .TrxDate, .Description, .Memo, .Status,
                .IsFake, .NormalMatchRange, .IsAwaitingReview, .IsAutoGenerated, .RepeatSeq, .ImportKey,
                .RepeatKey)
        End With
    End Sub

    '$Description Initial a new normal BaseTrx object with all default values.

    Public Sub NewEmptyNormal(ByVal datDate_ As Date)

        'NOTE: NewStartNormal() and NewEmptyNormal() must set the same properties.
        NumberInternal = ""
        TrxDateInternal = datDate_
        DescriptionInternal = ""
        MemoInternal = ""
        StatusInternal = TrxStatus.Unreconciled
        IsFakeInternal = False
        mcurNormalMatchRange = 0.0D
        IsAwaitingReviewInternal = False
        IsAutoGeneratedInternal = False
        RepeatSeqInternal = 0
        mstrImportKey = ""
        RepeatKeyInternal = ""
        ClearNormal()
    End Sub

    Private Sub ClearNormal()
        AmountInternal = 0
        BalanceInternal = 0
        mcolSplits = New List(Of TrxSplit)
    End Sub

    '$Description Update all updatable properties of this normal BaseTrx object.
    '   Un-applies any existing splits, then clears the existing splits and sets
    '   curAmount to zero. Normally followed by calls to AddSplit(), and finally
    '   Register.UpdateEnd().

    Public Sub UpdateStartNormal(ByVal strNumber_ As String, ByVal datDate_ As Date, ByVal strDescription_ As String,
                                 ByVal strMemo_ As String, ByVal lngStatus_ As TrxStatus, ByVal blnFake_ As Boolean,
                                 ByVal curNormalMatchRange_ As Decimal, ByVal blnAwaitingReview_ As Boolean,
                                 ByVal blnAutoGenerated_ As Boolean, ByVal intRepeatSeq_ As Integer,
                                 ByVal strImportKey_ As String, ByVal strRepeatKey_ As String)

        NumberInternal = strNumber_
        TrxDateInternal = datDate_
        DescriptionInternal = strDescription_
        MemoInternal = strMemo_
        StatusInternal = lngStatus_
        IsFakeInternal = blnFake_
        mcurNormalMatchRange = curNormalMatchRange_
        IsAwaitingReviewInternal = blnAwaitingReview_
        IsAutoGeneratedInternal = blnAutoGenerated_
        RepeatSeqInternal = intRepeatSeq_
        mstrImportKey = strImportKey_
        RepeatKeyInternal = strRepeatKey_

        ClearSplits()

        RaiseErrorOnBadData("UpdateStartNormal")

    End Sub

    Public Sub ClearSplits()
        AmountInternal = 0
        BalanceInternal = 0
        mcolSplits = New List(Of TrxSplit)
    End Sub

    Public Sub UpdateStartNormal(ByVal objTrx As BankTrx)
        With objTrx
            UpdateStartNormal(.Number, .TrxDate, .Description, .Memo, .Status, .IsFake,
                              .NormalMatchRange, .IsAwaitingReview, .IsAutoGenerated, .RepeatSeq,
                              .ImportKey, .RepeatKey)
        End With
    End Sub

    Public ReadOnly Property ImportKey() As String
        Get
            ImportKey = mstrImportKey
        End Get
    End Property

    Public ReadOnly Property NormalMatchRange() As Decimal
        Get
            NormalMatchRange = mcurNormalMatchRange
        End Get
    End Property

    Public ReadOnly Property AnyUnmatchedBudget() As Boolean
        Get
            AnyUnmatchedBudget = mblnAnyUnmatchedBudget
        End Get
    End Property

    Public ReadOnly Property SplitCount() As Integer
        Get
            SplitCount = mcolSplits.Count()
        End Get
    End Property

    Public ReadOnly Property FirstSplit() As TrxSplit
        Get
            Return mcolSplits.Item(0)
        End Get
    End Property

    Public ReadOnly Property SecondSplit() As TrxSplit
        Get
            Return mcolSplits.Item(1)
        End Get
    End Property

    Public ReadOnly Property Splits() As IEnumerable(Of TrxSplit)
        Get
            Return mcolSplits
        End Get
    End Property

    Public Overrides ReadOnly Property CategoryLabel As String
        Get
            Dim objSplit As TrxSplit
            Dim strCategoryKey As String = ""

            For Each objSplit In Me.Splits
                If strCategoryKey = "" Then
                    strCategoryKey = objSplit.CategoryKey
                ElseIf strCategoryKey <> objSplit.CategoryKey Then
                    Return "(mixed)"
                End If
            Next objSplit
            Return RegisterInternal.Account.Company.Categories.TranslateKey(strCategoryKey)
        End Get
    End Property

    Public Function SummarizeDueDates() As String

        Dim objSplit As TrxSplit
        Dim datDueDate As Date = Utilities.EmptyDate

        For Each objSplit In Me.Splits
            If datDueDate = Utilities.EmptyDate Then
                datDueDate = objSplit.DueDate
            ElseIf datDueDate <> objSplit.DueDate And objSplit.DueDate <> Utilities.EmptyDate Then
                Return "(mixed)"
            End If
        Next objSplit
        If datDueDate = Utilities.EmptyDate Then
            Return ""
        Else
            Return datDueDate.ToString(Utilities.DateFormatWithTwoDigitYear)
        End If

    End Function

    Public Function SummarizeInvoiceDates() As String

        Dim objSplit As TrxSplit
        Dim datInvoiceDate As Date = Utilities.EmptyDate

        For Each objSplit In Me.Splits
            If datInvoiceDate = Utilities.EmptyDate Then
                datInvoiceDate = objSplit.InvoiceDate
            ElseIf datInvoiceDate <> objSplit.InvoiceDate And objSplit.InvoiceDate <> Utilities.EmptyDate Then
                Return "(mixed)"
            End If
        Next objSplit
        If datInvoiceDate = Utilities.EmptyDate Then
            Return ""
        Else
            Return datInvoiceDate.ToString(Utilities.DateFormatWithTwoDigitYear)
        End If

    End Function

    Public Overrides ReadOnly Property PONumber() As String
        Get
            Dim objSplit As TrxSplit
            Dim strPONumberSummary As String = ""

            For Each objSplit In Me.Splits
                If strPONumberSummary = "" Then
                    strPONumberSummary = objSplit.PONumber
                ElseIf strPONumberSummary <> objSplit.PONumber And objSplit.PONumber <> "" Then
                    Return "(mixed)"
                End If
            Next objSplit
            Return strPONumberSummary
        End Get
    End Property

    Public Function SummarizeTerms() As String

        Dim objSplit As TrxSplit
        Dim strTerms As String = ""

        For Each objSplit In Me.Splits
            If strTerms = "" Then
                strTerms = objSplit.Terms
            ElseIf strTerms <> objSplit.Terms And objSplit.Terms <> "" Then
                Return "(mixed)"
            End If
        Next objSplit
        Return strTerms

    End Function

    Public Overrides ReadOnly Property InvoiceNum() As String
        Get
            Dim objSplit As TrxSplit
            Dim strInvNumber As String = ""

            For Each objSplit In Me.Splits
                If strInvNumber = "" Then
                    strInvNumber = objSplit.InvoiceNum
                ElseIf strInvNumber <> objSplit.InvoiceNum And objSplit.InvoiceNum <> "" Then
                    Return "(mixed)"
                End If
            Next objSplit
            Return strInvNumber
        End Get
    End Property

    Public Sub SummarizeSplits(ByVal objCompany As Company, ByRef strCategory As String, ByRef strPONumber As String,
                                ByRef strInvoiceNum As String, ByRef strInvoiceDate As String, ByRef strDueDate As String,
                               ByRef strTerms As String, ByRef strBudget As String, ByRef curAvailable As Decimal)

        Dim objSplit As TrxSplit
        Dim strCatKey As String = ""
        Dim strPONumber2 As String = ""
        Dim strInvoiceNum2 As String = ""
        Dim datInvoiceDate As Date
        Dim datDueDate As Date
        Dim strTerms2 As String = ""
        Dim strBudgetKey As String = ""
        Dim blnFirstSplit As Boolean

        blnFirstSplit = True
        curAvailable = 0
        For Each objSplit In Me.Splits
            If objSplit.BudgetKey = objCompany.PlaceholderBudgetKey Then
                curAvailable = curAvailable + objSplit.Amount
            End If
            If blnFirstSplit Then
                'Remember fields from the first split.
                strCatKey = objSplit.CategoryKey
                strPONumber2 = objSplit.PONumber
                strInvoiceNum2 = objSplit.InvoiceNum
                datInvoiceDate = objSplit.InvoiceDate
                datDueDate = objSplit.DueDate
                strTerms2 = objSplit.Terms
                strBudgetKey = objSplit.BudgetKey
                'Format fields from the first split.
                strCategory = objCompany.Categories.TranslateKey(strCatKey)
                strInvoiceNum = strInvoiceNum2
                strPONumber = strPONumber2
                If datInvoiceDate = Utilities.EmptyDate Then
                    strInvoiceDate = ""
                Else
                    strInvoiceDate = Utilities.FormatDate(datInvoiceDate)
                End If
                If datDueDate = Utilities.EmptyDate Then
                    strDueDate = ""
                Else
                    strDueDate = Utilities.FormatDate(datDueDate)
                End If
                strTerms = strTerms2
                strBudget = objCompany.Budgets.TranslateKey(strBudgetKey)
                blnFirstSplit = False
            Else
                If strCatKey <> objSplit.CategoryKey Then
                    strCategory = "(mixed)"
                End If
                If strPONumber2 <> objSplit.PONumber Then
                    strPONumber = "(mixed)"
                End If
                If strInvoiceNum2 <> objSplit.InvoiceNum Then
                    strInvoiceNum = "(mixed)"
                End If
                If datInvoiceDate <> objSplit.InvoiceDate Then
                    strInvoiceDate = "(mixed)"
                End If
                If datDueDate <> objSplit.DueDate Then
                    strDueDate = "(mixed)"
                End If
                If strTerms2 <> objSplit.Terms Then
                    strTerms = "(mixed)"
                End If
                If strBudgetKey <> objSplit.BudgetKey Then
                    strBudget = "(mixed)"
                End If
            End If
        Next objSplit

    End Sub

    Public Overrides Sub UnApply()
        'Regenerating generated BaseTrx must cause this and Apply() to be called.
        UnApplyFromBudgets()
        DeleteReplicaTrx()
    End Sub

    Public Overrides Sub Apply(ByVal blnLoading As Boolean)
        ApplyToBudgets()
        CreateReplicaTrx(blnLoading)
    End Sub

    '$Description Apply the Split objects in this BaseTrx to any matching budgets.
    '   Does nothing except for normal BaseTrx.

    Private Sub ApplyToBudgets()
        Dim blnNoMatch As Boolean
        mblnAnyUnmatchedBudget = False
        For Each objSplit As TrxSplit In mcolSplits
            If objSplit.Budget Is Nothing Then
                objSplit.ApplyToBudget(Register, TrxDateInternal, blnNoMatch)
                mblnAnyUnmatchedBudget = mblnAnyUnmatchedBudget Or blnNoMatch
            End If
        Next
    End Sub

    Public Sub CreateReplicaTrx(ByVal blnLoading As Boolean)
        If Not Register.Account Is Nothing Then
            Dim objCompany As Company = Register.Account.Company
            For Each objSplit As TrxSplit In mcolSplits
                objSplit.CreateReplicaTrx(objCompany)
            Next
        End If
    End Sub

    '$Description If Split objects for this BaseTrx have been applied to any budgets,
    '   un-apply them from those budgets. No error or other reporting if Split objects
    '   not currently applied to budgets. Does nothing except for normal BaseTrx.

    Public Sub UnApplyFromBudgets()
        For Each objSplit As TrxSplit In mcolSplits
            objSplit.UnApplyFromBudget(Register)
        Next objSplit
    End Sub

    Public Sub DeleteReplicaTrx()
        For Each objSplit As TrxSplit In mcolSplits
            objSplit.DeleteReplicaTrx()
        Next
    End Sub

    '$Description Update a BaseTrx as a result of matching it to imported bank data.

    Public Sub ImportUpdateBank(ByVal datDate_ As Date, ByVal strNumber_ As String, ByVal curAmount_ As Decimal, ByVal strImportKey_ As String)
        ImportUpdateShared()
        If Not IsNumeric(strNumber_) Then
            TrxDateInternal = datDate_
        End If
        NumberInternal = strNumber_
        AdjustSplitsProportionally(curAmount_)
        mstrImportKey = strImportKey_
    End Sub

    '$Description Update a BaseTrx with new number and amount.

    Public Sub ImportUpdateNumAmt(ByVal strNumber_ As String, ByVal curAmount_ As Decimal)
        ImportUpdateShared()
        NumberInternal = strNumber_
        AdjustSplitsProportionally(curAmount_)
    End Sub

    '$Description Update a generated BaseTrx with new amount, and make it non-generated.

    Public Sub ImportUpdateAmount(ByVal curAmount_ As Decimal)
        ImportUpdateShared()
        AdjustSplitsProportionally(curAmount_)
    End Sub

    Protected Sub ImportUpdateShared()
        IsAutoGeneratedInternal = False
        IsFakeInternal = False
    End Sub

    '$Description Adjust split amounts to add up to a new total amount
    '   but retain the same proportions relative to each other. Does nothing
    '   if the BaseTrx amount doesn't change, and assigns the entire amount to one
    '   split if either new or old amount is zero.
    '   Sets BaseTrx amount to curNewAmount.

    Protected Sub AdjustSplitsProportionally(ByVal curNewAmount As Decimal)
        Dim dblRatio As Double
        Dim curRemainder As Decimal
        Dim objSplit As TrxSplit
        Dim lngSplit As Integer
        Dim curThisSplit As Decimal

        If curNewAmount = AmountInternal Then
            Exit Sub
        End If
        'The proportional distribution algorithm breaks if either amount is zero.
        If curNewAmount = 0 Or AmountInternal = 0 Then
            lngSplit = 0
            For Each objSplit In mcolSplits
                lngSplit = lngSplit + 1
                If lngSplit = mcolSplits.Count() Then
                    objSplit.AdjustAmount(curNewAmount)
                    AmountInternal = curNewAmount
                Else
                    objSplit.AdjustAmount(0D)
                End If
            Next
            Exit Sub
        End If
        'Use proportional distribution.
        dblRatio = curNewAmount / AmountInternal
        curRemainder = curNewAmount
        lngSplit = 0
        AmountInternal = 0
        For Each objSplit In mcolSplits
            lngSplit = lngSplit + 1
            If lngSplit = mcolSplits.Count() Then
                objSplit.AdjustAmount(curRemainder)
                AmountInternal = AmountInternal + curRemainder
            Else
                curThisSplit = CType(System.Math.Round(objSplit.Amount * dblRatio, 2), Decimal)
                objSplit.AdjustAmount(curThisSplit)
                curRemainder = curRemainder - objSplit.Amount
                AmountInternal = AmountInternal + curThisSplit
            End If
        Next objSplit
    End Sub

    '$Description Add a new split to a BaseTrx and subtract that amount from another
    'split in the same BaseTrx. Normally both splits have the same PO# and this operation
    'represents applying an invoice to an open purchase order, but this routine
    'does not check the PO#.

    Public Sub ImportUpdatePurchaseOrder(ByVal objPOSplit As TrxSplit, ByVal objImportedSplit As TrxSplit)

        'A split with a PO# represents part of a purchase order due on that date.
        'If the split has no invoice number it represents a part of that purchase
        'order date that hasn't been matched to an invoice. If the split has an
        'invoice number it represents an invoice matched to that purchase order.
        'There should be only one split for a particular PO# and no invoice number
        'on a particular date, representing the uninvoiced portion of the purchase
        'order due on that date.
        'All splits related to the same purchase order and due on the same date
        'must belong to the same BaseTrx, or BaseTrx import will not divide the unreceived
        'portion of the purchase order correctly when applying invoices.
        With objImportedSplit
            objPOSplit.AdjustAmount(objPOSplit.Amount - .Amount)
            AmountInternal = AmountInternal - .Amount
            AddSplit(.Memo, .CategoryKey, .PONumber, .InvoiceNum, .InvoiceDate, .DueDate,
                     .Terms, objPOSplit.BudgetKey, .Amount)
        End With

    End Sub

    Private Sub SetSplitDocInfo(ByVal strPONumber_ As String, ByVal strInvoiceNum_ As String, ByVal datInvoiceDate_ As Date,
                                ByVal datDueDate_ As Date, ByVal strTerms_ As String)
        Dim objSplit As TrxSplit
        For Each objSplit In mcolSplits
            With objSplit
                .PONumber = strPONumber_
                .InvoiceNum = strInvoiceNum_
                .InvoiceDate = datInvoiceDate_
                .DueDate = datDueDate_
                .Terms = strTerms_
            End With
        Next objSplit
    End Sub

    '$Description Add a split to the BaseTrx. Updates the overall BaseTrx amount as well,
    '   but does not apply to budget because the budget BaseTrx may not exist yet.
    '   This is the only valid way to modify the splits, or the BaseTrx amount.

    Public Sub AddSplit(ByVal strMemo_ As String, ByVal strCategoryKey_ As String, ByVal strPONumber_ As String,
                        ByVal strInvoiceNum_ As String, ByVal datInvoiceDate_ As Date, ByVal datDueDate_ As Date,
                        ByVal strTerms_ As String, ByVal strBudgetKey_ As String, ByVal curAmount_ As Decimal)

        Dim objSplit As TrxSplit
        objSplit = New TrxSplit
        objSplit.Init(strMemo_, strCategoryKey_, strPONumber_, strInvoiceNum_, datInvoiceDate_, datDueDate_, strTerms_, strBudgetKey_, curAmount_)
        objSplit.Parent = Me
        mcolSplits.Add(objSplit)
        AmountInternal = AmountInternal + curAmount_

    End Sub

    '$Description Like other AddSplit(), but clones an existing split.

    Public Sub AddSplit(ByVal objSrcSplit As TrxSplit)
        Dim objDstSplit As TrxSplit
        objDstSplit = New TrxSplit
        With objSrcSplit
            objDstSplit.Init(.Memo, .CategoryKey, .PONumber, .InvoiceNum, .InvoiceDate, .DueDate, .Terms, .BudgetKey, .Amount)
            objDstSplit.Parent = Me
            mcolSplits.Add(objDstSplit)
            AmountInternal = AmountInternal + .Amount
        End With
    End Sub

    Public Sub CopySplits(ByVal objDstTrx As BankTrx)
        Dim objSrcSplit As TrxSplit
        For Each objSrcSplit In mcolSplits
            objDstTrx.AddSplit(objSrcSplit)
        Next objSrcSplit
    End Sub

    Public Overrides Function CloneTrx(ByVal blnWillAddToRegister As Boolean) As BaseTrx
        Dim objNormalTrx As BankTrx = New BankTrx(RegisterInternal)
        objNormalTrx.NewStartNormal(blnWillAddToRegister, Me)
        CopySplits(objNormalTrx)
        Return objNormalTrx
    End Function

    Public Overrides Sub Validate()
        Dim objSplit As TrxSplit
        Dim curTotal As Decimal
        Dim objCategories As CategoryTranslator = RegisterInternal.Account.Company.Categories
        Dim blnAccountIsPersonal As Boolean = (RegisterInternal.Account.AcctType = Account.AccountType.Personal)
        MyBase.Validate()
        If mcolSplits Is Nothing Then
            Register.FireValidationError(Me, "Missing split collection")
        Else
            curTotal = 0
            For Each objSplit In mcolSplits
                curTotal = curTotal + objSplit.Amount
                If Not objSplit.Budget Is Nothing Then
                    If objSplit.Budget.GetType() IsNot GetType(BudgetTrx) Then
                        Register.FireValidationError(Me, "Split applied to non-budget trx")
                    End If
                    If objSplit.BudgetKey = "" Then
                        Register.FireValidationError(Me, "Split applied to budget trx has no budget key")
                    End If
                    If objSplit.BudgetKey <> objSplit.Budget.BudgetKey Then
                        Register.FireValidationError(Me, "Split applied to budget trx has wrong budget key")
                    End If
                End If
                If blnAccountIsPersonal <> CategoryTranslator.IsPersonal(objCategories.KeyToValue1(objSplit.CategoryKey)) Then
                    Register.FireValidationError(Me, "Split category mixes personal and business")
                End If
                Dim intDotOffset As Integer = objSplit.CategoryKey.IndexOf("."c)
                If intDotOffset > 0 Then
                    Dim intAccountKey As Integer = Integer.Parse(objSplit.CategoryKey.Substring(0, intDotOffset))
                    If intAccountKey = Register.Account.AccountKey Then
                        Register.FireValidationError(Me, "Split category uses the same account")
                    End If
                End If
            Next objSplit
            If curTotal <> AmountInternal Then
                Register.FireValidationError(Me, "Normal trx splits add up wrong")
            End If
        End If
        If IsFakeInternal Then
            If mstrImportKey <> "" Then
                Register.FireValidationError(Me, "Normal trx cannot have import key if it is fake")
            End If
            If StatusInternal <> TrxStatus.Unreconciled Then
                Register.FireValidationError(Me, "Normal trx must be unreconciled if it is fake")
            End If
        End If
    End Sub

    Public Overrides ReadOnly Property TrxTypeSortKey As Integer
        Get
            Return 4
        End Get
    End Property

    Public Overrides ReadOnly Property DocNumberSortKey As String
        Get
            Return Me.FirstSplit.InvoiceNum
        End Get
    End Property

End Class
