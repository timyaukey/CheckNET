Option Strict Off
Option Explicit On

Public Class Trx
    '2345667890123456789012345678901234567890123456789012345678901234567890123456789012345

    'Represents one transaction.

    'To create a transaction and add it to a Register, create a Trx instance and
    'call NewStartNormal(), NewStartBudget() or NewStartTransfer() depending on the
    'type of transaction you want to create. If you called NewStartNormal(), add at
    'least one split with AddSplit(). Then call Register.NewLoadEnd() if you are in
    'the process of loading a Register from some external source and will note the
    'end of the load by calling Register.LoadPostProcessing(). Otherwise call
    'Register.NewAddEnd(), which is what will typically happen if you are adding to
    'a Register which is already visible in the UI.

    'To update an existing transaction, call UpdateStartNormal(),
    'UpdateStartBudget() or UpdateStartTransfer() as appropriate for the transaction
    'type. Then call AddSplit() at least once if you called UpdateStartNormal().
    'Then call Register.UpdateEnd().

    'The UI is not updated directly by the caller to these methods, rather it is
    'updated indirectly by responding to events fired by the Register object as
    'its methods are called and complete their tasks.

    Public Enum TrxStatus
        'Missing value (should never be this).
        gintTRXSTS_MISSING = 0
        'Unreconciled (new).
        glngTRXSTS_UNREC = 1
        'Reconciled.
        glngTRXSTS_RECON = 2
        'Non-bank (budget, transfer, etc.)
        glngTRXSTS_NONBANK = 3
        'Selected in current reconciliation.
        glngTRXSTS_SELECTED = 4
    End Enum

    Public Enum TrxType
        'Missing value (should never be this).
        glngTRXTYP_MISSING = 0
        'Ordinary transaction.
        glngTRXTYP_NORMAL = 1
        'Budget transaction (must be fake).
        glngTRXTYP_BUDGET = 2
        'Transfer transaction.
        glngTRXTYP_TRANSFER = 3
    End Enum

    Public Enum TrxSearchField
        glngTRXSFL_NUMBER
        glngTRXSFL_DESCR
        glngTRXSFL_CATKEY
        glngTRXSFL_AMOUNT
        glngTRXSFL_MEMO
        glngTRXSFL_INVNUM
        glngTRXSFL_PONUMBER
    End Enum

    Public Enum TrxSearchType
        glngTRXSTP_EQUAL = 1
        glngTRXSTP_CONTAINS = 2
        glngTRXSTP_STARTS = 3
    End Enum

    Public Enum RepeatUnit
        glngRPTUNT_MISSING = 0
        glngRPTUNT_DAY = 1
        glngRPTUNT_WEEK = 2
        glngRPTUNT_MONTH = 3
    End Enum

    'Editable properties.

    'Transaction number.
    Private mstrNumber As String
    'Transaction date.
    Private mdatDate As Date
    'Payee name, or other description.
    Private mstrDescription As String
    'Transaction memo.
    Private mstrMemo As String
    'Transaction status.
    Private mlngStatus As TrxStatus
    'Is this transaction fake (future dated)?
    Private mblnFake As Boolean
    'Transaction type.
    Private mlngType As TrxType
    'Original budget amount, or zero if mblnBudget=False.
    'Is NOT changed as other Trx are applied and unapplied to this one.
    'Sign has the same meaning as Split.curAmount, so is normally negative.
    Private mcurBudgetLimit As Decimal
    'Last date in the budget period. Budget period starts at mdatDate.
    Private mdatBudgetEnds As Date
    'Amount of a subaccount transfer.
    Private mcurTransferAmount As Decimal
    'Trx amount may be different from a matching normal Trx
    'by this amount, either positive or negative.
    Private mcurNormalMatchRange As Decimal
    'Trx needs to be reviewed by the operator.
    Private mblnAwaitingReview As Boolean
    'Trx was added to register as part of an automatically generated
    'series. Such a Trx will always have a non-empty mstrRepeatKey,
    'but a non-empty mstrRepeatKey does not imply mblnAutoGenerated=True.
    Private mblnAutoGenerated As Boolean
    'Sequence number of Trx in generated sequence.
    Private mintRepeatSeq As Short

    'Editable properties for repeating transactions.

    'Unit of time to which mintRptNumber applies.
    Private mlngRptUnit As RepeatUnit
    'Number of mlngRptUnit in repeat interval.
    Private mintRptNumber As Short
    'Generate repeated Trx through this date.
    Private mdatRptEnd As Date
    'Unit of time to which mintBudgetPeriodNumber applies.
    Private mlngBudgetPeriodUnit As RepeatUnit
    'Number of mlngBudgetPeriodUnit in budget period.
    Private mintBudgetPeriodNumber As Short

    'Non-editable properties.
    'These will not be changed by UpdateStart().

    'Unique key identifying an external transaction imported to create this Trx.
    'Used for matching new imported Trx against prior imports, to avoid duplicates.
    Private mstrImportKey As String
    'Unique ID used when creating Trx as part of auto-generated series.
    'All fake and real Trx originating from the same single or repeating
    'fake Trx have the same value. Is a foreign key into some external database
    'defining how to create fake Trx.
    Private mstrRepeatKey As String
    'For budget Trx, a unique ID for that budget. All budget Trx in a repeating
    'budget will have the same mstrBudgetKey, and the appropriate one for applying
    'Trx will be chosen by the budget period. Is a foreign key into some external
    'database defining how to create budget Trx.
    Private mstrBudgetKey As String
    'For transfer Trx, the unique ID of the subaccount being transfered to or from.
    'For transfer Trx, there must exist a transfer Trx in this account with the same
    'date, the RegisterKey of THIS subaccount, and the negative of the amount of
    'this Trx. For non-transfer Trx, must be an empty string.
    Private mstrTransferKey As String

    'Computed properties.

    'Positive for a credit, negative for a debit.
    'Is computed from the sum of the Split amounts.
    'Changes when this Trx is a budget Trx, and other Trx are applied and unapplied.
    Private mcurAmount As Decimal
    'Register balance after mcurAmount added.
    Private mcurBalance As Decimal
    'Key for sorting register entries.
    Private mstrSortKey As String
    'Amount applied toward budget. Magnitude may be greater than mcurBudgetLimit,
    'in which case mcurAmount will equal zero instead of a credit.
    Private mcurBudgetApplied As Decimal
    'Collection of Split objects belonging to other Trx and applied to this
    'budget Trx. Nothing if this is not a budget Trx.
    Private mcolAppliedSplits As Collection
    'Collection of Split objects belonging to this Trx.
    Private mcolSplits As Collection
    'True iff any split with a budget key was not matched to a budget Trx,
    'and the Trx date was not before the earliest budget in the register.
    Private mblnAnyUnmatchedBudget As Boolean

    '$Description Initialize a new normal Trx object. Normally followed by calls to
    '   AddSplit(), and finally either Register.NewLoadEnd() or Register.NewAddEnd().
    '$Param objReg The Register this Trx will be added to. May be Nothing, in which case
    '   the caller is responsible for calling ClearFirstAffected() for the appropriate
    '   Register before NewAddEnd().

    Public Sub NewStartNormal(ByVal objReg As Register, ByVal strNumber_ As String, ByVal datDate_ As Date, _
                              ByVal strDescription_ As String, ByVal strMemo_ As String, ByVal lngStatus_ As TrxStatus, _
                              ByVal blnFake_ As Boolean, ByVal curNormalMatchRange_ As Decimal, _
                              ByVal blnAwaitingReview_ As Boolean, ByVal blnAutoGenerated_ As Boolean, _
                              ByVal intRepeatSeq_ As Short, ByVal strImportKey_ As String, _
                              ByVal strRepeatKey_ As String)

        If Not objReg Is Nothing Then
            objReg.ClearFirstAffected()
        End If

        'NOTE: NewStartNormal() and NewEmptyNormal() must set the same properties.
        mlngType = TrxType.glngTRXTYP_NORMAL
        mstrNumber = strNumber_
        mdatDate = datDate_
        mstrDescription = strDescription_
        mstrMemo = strMemo_
        mlngStatus = lngStatus_
        mblnFake = blnFake_
        mcurNormalMatchRange = curNormalMatchRange_
        mblnAwaitingReview = blnAwaitingReview_
        mblnAutoGenerated = blnAutoGenerated_
        mintRepeatSeq = intRepeatSeq_
        mstrImportKey = strImportKey_
        mstrRepeatKey = strRepeatKey_

        ClearNormal()

        RaiseErrorOnBadData("NewStartNormal")

    End Sub

    Public Sub NewStartNormal(ByVal objReg As Register, ByVal strNumber_ As String, ByVal datDate_ As Date, _
                              ByVal strDescription_ As String, ByVal strMemo_ As String, ByVal lngStatus_ As TrxStatus, _
                              ByVal objData As TrxGenImportData)
        With objData
            NewStartNormal(objReg, strNumber_, datDate_, strDescription_, strMemo_, lngStatus_, _
                .blnFake, .curNormalMatchRange, .blnAwaitingReview, .blnAutoGenerated, _
                .intRepeatSeq, .strImportKey, .strRepeatKey)
        End With
    End Sub

    Public Sub NewStartNormal(ByVal objReg As Register, ByVal objTrx As Trx)
        With objTrx
            NewStartNormal(objReg, .strNumber, .datDate, .strDescription, .strMemo, .lngStatus, _
                .blnFake, .curNormalMatchRange, .blnAwaitingReview, .blnAutoGenerated, .intRepeatSeq, .strImportKey, _
                .strRepeatKey)
        End With
    End Sub

    '$Description Initial a new normal Trx object with all default values.

    Public Sub NewEmptyNormal(ByVal objReg As Register, ByVal datDate_ As Date)

        'NOTE: NewStartNormal() and NewEmptyNormal() must set the same properties.
        mlngType = TrxType.glngTRXTYP_NORMAL
        mstrNumber = ""
        mdatDate = datDate_
        mstrDescription = ""
        mstrMemo = ""
        mlngStatus = TrxStatus.glngTRXSTS_UNREC
        mblnFake = False
        mcurNormalMatchRange = 0.0#
        mblnAwaitingReview = False
        mblnAutoGenerated = False
        mintRepeatSeq = 0
        mstrImportKey = ""
        mstrRepeatKey = ""

        ClearNormal()
    End Sub

    Private Sub ClearNormal()
        mstrTransferKey = ""
        mcurTransferAmount = 0
        mcurBudgetLimit = 0
        mdatBudgetEnds = System.DateTime.FromOADate(0)
        mcurBudgetApplied = 0

        mcurAmount = 0
        mcurBalance = 0

        'UPGRADE_NOTE: Object mcolAppliedSplits may not be destroyed until it is garbage collected. Click for more: 'ms-help://MS.VSCC.v90/dv_commoner/local/redirect.htm?keyword="6E35BFF6-CD74-4B09-9689-3E1A43DF8969"'
        mcolAppliedSplits = Nothing
        mcolSplits = New Collection
    End Sub

    '$Description Initialize a new budget Trx object. Normally followed by
    '   Register.NewLoadEnd() or Register.NewAddEnd().

    Public Sub NewStartBudget(ByVal objReg As Register, ByVal datDate_ As Date, ByVal strDescription_ As String, ByVal strMemo_ As String, ByVal blnAwaitingReview_ As Boolean, ByVal blnAutoGenerated_ As Boolean, ByVal intRepeatSeq_ As Short, ByVal strRepeatKey_ As String, ByVal curBudgetLimit_ As Decimal, ByVal datBudgetEnds_ As Date, ByVal strBudgetKey_ As String)

        If Not objReg Is Nothing Then
            objReg.ClearFirstAffected()
        End If

        mlngType = TrxType.glngTRXTYP_BUDGET
        mstrNumber = "Budget"
        mdatDate = datDate_
        mstrDescription = strDescription_
        mstrMemo = strMemo_
        mlngStatus = TrxStatus.glngTRXSTS_NONBANK
        mblnFake = True
        mcurNormalMatchRange = 0
        mblnAwaitingReview = blnAwaitingReview_
        mblnAutoGenerated = blnAutoGenerated_
        mintRepeatSeq = intRepeatSeq_
        mstrImportKey = ""
        mstrRepeatKey = strRepeatKey_

        mstrTransferKey = ""
        mcurTransferAmount = 0
        mcurBudgetLimit = curBudgetLimit_
        mdatBudgetEnds = datBudgetEnds_
        mstrBudgetKey = strBudgetKey_
        mcurBudgetApplied = 0

        If Not objReg Is Nothing Then
            SetAmountForBudget(objReg.datOldestBudgetEndAllowed)
        End If
        mcurBalance = 0

        mcolAppliedSplits = New Collection
        'UPGRADE_NOTE: Object mcolSplits may not be destroyed until it is garbage collected. Click for more: 'ms-help://MS.VSCC.v90/dv_commoner/local/redirect.htm?keyword="6E35BFF6-CD74-4B09-9689-3E1A43DF8969"'
        mcolSplits = Nothing

        RaiseErrorOnBadData("NewStartBudget")
        RaiseErrorOnBadBudget("NewStartBudget")

    End Sub

    '$Description Initialize a new transfer Trx object. Normally followed by
    '   either Register.NewLoadEnd() or Register.NewAddEnd().

    Public Sub NewStartTransfer(ByVal objReg As Register, ByVal datDate_ As Date, ByVal strDescription_ As String, ByVal strMemo_ As String, ByVal blnFake_ As Boolean, ByVal blnAwaitingReview_ As Boolean, ByVal blnAutoGenerated_ As Boolean, ByVal intRepeatSeq_ As Short, ByVal strRepeatKey_ As String, ByVal strTransferKey_ As String, ByVal curTransferAmount_ As Decimal)

        If Not objReg Is Nothing Then
            objReg.ClearFirstAffected()
        End If

        mlngType = TrxType.glngTRXTYP_TRANSFER
        mstrNumber = "XFR"
        mdatDate = datDate_
        mstrDescription = strDescription_
        mstrMemo = strMemo_
        mlngStatus = TrxStatus.glngTRXSTS_NONBANK
        mblnFake = blnFake_
        mcurNormalMatchRange = 0
        mblnAwaitingReview = blnAwaitingReview_
        mblnAutoGenerated = blnAutoGenerated_
        mintRepeatSeq = intRepeatSeq_
        mstrImportKey = ""
        mstrRepeatKey = strRepeatKey_

        mstrTransferKey = strTransferKey_
        mcurTransferAmount = curTransferAmount_
        mcurBudgetLimit = 0
        mdatBudgetEnds = System.DateTime.FromOADate(0)
        mcurBudgetApplied = 0

        mcurAmount = mcurTransferAmount
        mcurBalance = 0

        'UPGRADE_NOTE: Object mcolAppliedSplits may not be destroyed until it is garbage collected. Click for more: 'ms-help://MS.VSCC.v90/dv_commoner/local/redirect.htm?keyword="6E35BFF6-CD74-4B09-9689-3E1A43DF8969"'
        mcolAppliedSplits = Nothing
        'UPGRADE_NOTE: Object mcolSplits may not be destroyed until it is garbage collected. Click for more: 'ms-help://MS.VSCC.v90/dv_commoner/local/redirect.htm?keyword="6E35BFF6-CD74-4B09-9689-3E1A43DF8969"'
        mcolSplits = Nothing

        RaiseErrorOnBadData("NewStartTransfer")
        RaiseErrorOnBadTransfer("NewStartTransfer")

    End Sub

    '$Description Update all updatable properties of this normal Trx object.
    '   Un-applies any existing splits, then clears the existing splits and sets
    '   curAmount to zero. Normally followed by calls to AddSplit(), and finally
    '   Register.UpdateEnd().

    Public Sub UpdateStartNormal(ByVal objReg As Register, ByVal strNumber_ As String, ByVal datDate_ As Date, ByVal strDescription_ As String, _
                                 ByVal strMemo_ As String, ByVal lngStatus_ As TrxStatus, ByVal blnFake_ As Boolean, _
                                 ByVal curNormalMatchRange_ As Decimal, ByVal blnAwaitingReview_ As Boolean, _
                                 ByVal blnAutoGenerated_ As Boolean, ByVal intRepeatSeq_ As Short, _
                                 ByVal strImportKey_ As String, ByVal strRepeatKey_ As String)

        objReg.ClearFirstAffected()

        If mlngType <> TrxType.glngTRXTYP_NORMAL Then
            gRaiseError("UpdateStartNormal used for wrong transaction type")
        End If

        UnApplyFromBudgets(objReg)
        ClearRepeatTrx(objReg)

        mstrNumber = strNumber_
        mdatDate = datDate_
        mstrDescription = strDescription_
        mstrMemo = strMemo_
        mlngStatus = lngStatus_
        mblnFake = blnFake_
        mcurNormalMatchRange = curNormalMatchRange_
        mblnAwaitingReview = blnAwaitingReview_
        mblnAutoGenerated = blnAutoGenerated_
        mintRepeatSeq = intRepeatSeq_
        mstrImportKey = strImportKey_
        mstrRepeatKey = strRepeatKey_

        mcurAmount = 0
        mcurBalance = 0

        mcolSplits = New Collection

        RaiseErrorOnBadData("UpdateStartNormal")

    End Sub

    Public Sub UpdateStartNormal(ByVal objReg As Register, ByVal objTrx As Trx)
        With objTrx
            UpdateStartNormal(objReg, .strNumber, .datDate, .strDescription, .strMemo, .lngStatus, .blnFake, _
                              .curNormalMatchRange, .blnAwaitingReview, .blnAutoGenerated, .intRepeatSeq, _
                              .strImportKey, .strRepeatKey)
        End With
    End Sub

    '$Description Update all updatable properties of this budget Trx object.
    '   Normally followed Register.UpdateEnd().

    Public Sub UpdateStartBudget(ByVal objReg As Register, ByVal datDate_ As Date, ByVal strDescription_ As String, ByVal strMemo_ As String, ByVal blnAwaitingReview_ As Boolean, ByVal blnAutoGenerated_ As Boolean, ByVal intRepeatSeq_ As Short, ByVal strRepeatKey_ As String, ByVal curBudgetLimit_ As Decimal, ByVal datBudgetEnds_ As Date, ByVal strBudgetKey_ As String)

        objReg.ClearFirstAffected()
        ClearRepeatTrx(objReg)

        If mlngType <> TrxType.glngTRXTYP_BUDGET Then
            gRaiseError("UpdateStartBudget used for wrong transaction type")
        End If

        mdatDate = datDate_
        mstrDescription = strDescription_
        mstrMemo = strMemo_
        mblnAwaitingReview = blnAwaitingReview_
        mblnAutoGenerated = blnAutoGenerated_
        mintRepeatSeq = intRepeatSeq_
        mstrRepeatKey = strRepeatKey_
        mcurBudgetLimit = curBudgetLimit_
        mdatBudgetEnds = datBudgetEnds_
        mstrBudgetKey = strBudgetKey_

        'We do NOT clear mcurBudgetApplied, because updating the budget
        'does not change what splits have been applied to it.
        SetAmountForBudget(objReg.datOldestBudgetEndAllowed)
        mcurBalance = 0

        'Will not unapply any budgets, even though the budget period or budget key
        'may have been changed by this update. The caller should warn the operator
        'that normal transactions will not be reapplied to budgets until they are
        'edited and saved or the register reloaded.

        RaiseErrorOnBadData("UpdateStartBudget")
        RaiseErrorOnBadBudget("UpdateStartBudget")
    End Sub

    '$Description Update all updatable properties of this Trx transfer object.
    '   Normally followed by Register.UpdateEnd().

    Public Sub UpdateStartTransfer(ByVal objReg As Register, ByVal datDate_ As Date, ByVal strDescription_ As String, ByVal strMemo_ As String, ByVal blnFake_ As Boolean, ByVal blnAwaitingReview_ As Boolean, ByVal blnAutoGenerated_ As Boolean, ByVal intRepeatSeq_ As Short, ByVal strRepeatKey_ As String, ByVal curTransferAmount_ As Decimal)

        objReg.ClearFirstAffected()
        ClearRepeatTrx(objReg)

        If mlngType <> TrxType.glngTRXTYP_TRANSFER Then
            gRaiseError("UpdateStartTransfer used for wrong transaction type")
        End If

        mdatDate = datDate_
        mstrDescription = strDescription_
        mstrMemo = strMemo_
        mblnFake = blnFake_
        mblnAwaitingReview = blnAwaitingReview_
        mblnAutoGenerated = blnAutoGenerated_
        mintRepeatSeq = intRepeatSeq_
        mstrRepeatKey = strRepeatKey_
        mcurTransferAmount = curTransferAmount_

        'We do NOT clear mcurBudgetApplied, because updating the budget
        'does not change what splits have been applied to it.
        mcurAmount = mcurTransferAmount
        mcurBalance = 0

        RaiseErrorOnBadData("UpdateStartTransfer")
        RaiseErrorOnBadTransfer("UpdateStartTransfer")
    End Sub

    '$Description Set all repeating Trx properties common to all Trx types.

    Public Sub SetSharedRptProps(ByVal lngRptUnit_ As RepeatUnit, ByVal intRptNumber_ As Short, ByVal datRptEnd_ As Date)

        mlngRptUnit = lngRptUnit_
        mintRptNumber = intRptNumber_
        mdatRptEnd = datRptEnd_
    End Sub

    '$Description Set all repeating Trx properties exclusive to budget Trx.

    Public Sub SetBudgetRptProps(ByVal lngBudgetPeriodUnit_ As RepeatUnit, ByVal intBudgetPeriodNumber_ As Short)

        mlngBudgetPeriodUnit = lngBudgetPeriodUnit_
        mintBudgetPeriodNumber = intBudgetPeriodNumber_
    End Sub

    Private Sub ClearRepeatTrx(ByVal objReg As Register)
        If mintRepeatSeq > 0 Then
            'Remove the repeat trx index entry for the old values
            'of repeat key and repeat seq, which may be different
            'than the new ones.
            objReg.RemoveRepeatTrx(Me)
        End If
    End Sub

    Public ReadOnly Property strRepeatId() As String
        Get
            strRepeatId = gstrMakeRepeatId(mstrRepeatKey, mintRepeatSeq)
        End Get
    End Property

    Public ReadOnly Property strSortKey() As String
        Get
            strSortKey = mstrSortKey
        End Get
    End Property

    Public ReadOnly Property lngType() As TrxType
        Get
            lngType = mlngType
        End Get
    End Property

    Public ReadOnly Property strNumber() As String
        Get
            strNumber = mstrNumber
        End Get
    End Property

    Public ReadOnly Property datDate() As Date
        Get
            datDate = mdatDate
        End Get
    End Property

    Public ReadOnly Property strDescription() As String
        Get
            strDescription = mstrDescription
        End Get
    End Property

    Public ReadOnly Property strMemo() As String
        Get
            strMemo = mstrMemo
        End Get
    End Property

    Public ReadOnly Property lngStatus() As TrxStatus
        Get
            lngStatus = mlngStatus
        End Get
    End Property

    Public ReadOnly Property strStatus() As String
        Get
            Select Case mlngStatus
                Case TrxStatus.glngTRXSTS_NONBANK
                    strStatus = "NonBank"
                Case TrxStatus.glngTRXSTS_UNREC
                    strStatus = "Unreconciled"
                Case TrxStatus.glngTRXSTS_SELECTED
                    strStatus = "Selected"
                Case TrxStatus.glngTRXSTS_RECON
                    strStatus = "Reconciled"
                Case Else
                    strStatus = ""
            End Select
        End Get
    End Property


    Public Property blnFake() As Boolean
        Get
            blnFake = mblnFake
        End Get
        Set(ByVal Value As Boolean)
            mblnFake = Value
        End Set
    End Property

    Public ReadOnly Property strFakeStatus() As String
        Get
            If mblnAutoGenerated Then
                strFakeStatus = "Gen"
            ElseIf mblnFake Then
                strFakeStatus = "Fake"
            Else
                strFakeStatus = ""
            End If
        End Get
    End Property

    Public ReadOnly Property curBudgetLimit() As Decimal
        Get
            curBudgetLimit = mcurBudgetLimit
        End Get
    End Property

    Public ReadOnly Property datBudgetEnds() As Date
        Get
            datBudgetEnds = mdatBudgetEnds
        End Get
    End Property

    Public ReadOnly Property curBudgetApplied() As Decimal
        Get
            curBudgetApplied = mcurBudgetApplied
        End Get
    End Property

    Public ReadOnly Property blnAnyUnmatchedBudget() As Boolean
        Get
            blnAnyUnmatchedBudget = mblnAnyUnmatchedBudget
        End Get
    End Property

    Public ReadOnly Property strImportKey() As String
        Get
            strImportKey = mstrImportKey
        End Get
    End Property

    Public ReadOnly Property strRepeatKey() As String
        Get
            strRepeatKey = mstrRepeatKey
        End Get
    End Property

    Public ReadOnly Property strTransferKey() As String
        Get
            strTransferKey = mstrTransferKey
        End Get
    End Property

    Public ReadOnly Property strBudgetKey() As String
        Get
            strBudgetKey = mstrBudgetKey
        End Get
    End Property

    Public ReadOnly Property curNormalMatchRange() As Decimal
        Get
            curNormalMatchRange = mcurNormalMatchRange
        End Get
    End Property

    Public ReadOnly Property curTransferAmount() As Decimal
        Get
            curTransferAmount = mcurTransferAmount
        End Get
    End Property

    Public ReadOnly Property blnAwaitingReview() As Boolean
        Get
            blnAwaitingReview = mblnAwaitingReview
        End Get
    End Property

    Public ReadOnly Property blnAutoGenerated() As Boolean
        Get
            blnAutoGenerated = mblnAutoGenerated
        End Get
    End Property

    Public ReadOnly Property intRepeatSeq() As Short
        Get
            intRepeatSeq = mintRepeatSeq
        End Get
    End Property

    Public ReadOnly Property curAmount() As Decimal
        Get
            curAmount = mcurAmount
        End Get
    End Property

    Public ReadOnly Property curBalance() As Decimal
        Get
            curBalance = mcurBalance
        End Get
    End Property

    Public ReadOnly Property lngRptUnit() As RepeatUnit
        Get
            lngRptUnit = mlngRptUnit
        End Get
    End Property

    Public ReadOnly Property intRptNumber() As Short
        Get
            intRptNumber = mintRptNumber
        End Get
    End Property

    Public ReadOnly Property datRptEnd() As Date
        Get
            datRptEnd = mdatRptEnd
        End Get
    End Property

    Public ReadOnly Property lngBudgetPeriodUnit() As RepeatUnit
        Get
            lngBudgetPeriodUnit = mlngBudgetPeriodUnit
        End Get
    End Property

    Public ReadOnly Property intBudgetPeriodNumber() As Short
        Get
            intBudgetPeriodNumber = mintBudgetPeriodNumber
        End Get
    End Property

    Public ReadOnly Property lngSplits() As Integer
        Get
            If mlngType <> TrxType.glngTRXTYP_NORMAL Then
                gRaiseError("Trx.intSplits only allowed on normal transaction")
            End If
            lngSplits = mcolSplits.Count()
        End Get
    End Property

    Public ReadOnly Property objSplit(ByVal lngIndex As Integer) As Split_Renamed
        Get
            If mlngType <> TrxType.glngTRXTYP_NORMAL Then
                gRaiseError("Trx.objSplit only allowed on normal transaction")
            End If
            If lngIndex < 1 Or lngIndex > mcolSplits.Count() Then
                gRaiseError("Invalid index " & lngIndex & " in Trx.objSplit")
            End If
            objSplit = mcolSplits.Item(lngIndex)
        End Get
    End Property

    Public ReadOnly Property colSplits() As Collection
        Get
            colSplits = mcolSplits
        End Get
    End Property

    Public ReadOnly Property lngAppliedSplits() As Integer
        Get
            If mlngType <> TrxType.glngTRXTYP_BUDGET Then
                gRaiseError("Trx.lngAppliedSplits only allowed on budget transaction")
            End If
            lngAppliedSplits = mcolAppliedSplits.Count()
        End Get
    End Property

    Public ReadOnly Property objAppliedSplit(ByVal lngIndex As Integer) As Split_Renamed
        Get
            If mlngType <> TrxType.glngTRXTYP_BUDGET Then
                gRaiseError("Trx.objAppliedSplit only allowed on budget transaction")
            End If
            objAppliedSplit = mcolAppliedSplits.Item(lngIndex)
        End Get
    End Property

    Private Sub RaiseErrorOnBadData(ByVal strRoutine As String)
        If mdatDate = System.DateTime.FromOADate(0) Then
            gRaiseError("Missing date in " & strRoutine)
        End If
        If mstrDescription = "" Then
            gRaiseError("Missing description in " & strRoutine)
        End If
        If mlngStatus = TrxStatus.gintTRXSTS_MISSING Then
            gRaiseError("Missing status in " & strRoutine)
        End If
    End Sub

    Private Sub RaiseErrorOnBadBudget(ByVal strRoutine As String)
        If mstrBudgetKey = "" Then
            gRaiseError("Missing budget key in " & strRoutine)
        End If
        If mdatBudgetEnds = System.DateTime.FromOADate(0) Then
            gRaiseError("Missing budget end date in " & strRoutine)
        End If
        If mdatBudgetEnds < mdatDate Then
            gRaiseError("Budget period ends before it begins")
        End If
    End Sub

    Private Sub RaiseErrorOnBadTransfer(ByVal strRoutine As String)
        If mstrTransferKey = "" Then
            gRaiseError("Missing transfer key in " & strRoutine)
        End If
    End Sub

    '$Description Update a Trx as a result of matching it to imported bank data.

    Public Sub ImportUpdateBank(ByVal datDate_ As Date, ByVal strNumber_ As String, ByVal blnFake_ As Boolean, ByVal curAmount_ As Decimal, ByVal strImportKey_ As String)

        'Can change from fake to real, but not the reverse.
        If mblnFake Then
            mblnFake = blnFake_
        End If
        mblnAutoGenerated = False
        If Not IsNumeric(strNumber_) Then
            mdatDate = datDate_
        End If
        mstrNumber = strNumber_
        AdjustSplitsProportionally(curAmount_)
        'Commented out after realizing that bank imports never have doc info.
        ''Only fake imports can have doc info, and we don't want to
        ''copy blank doc info over potentially non-blank.
        'If blnFake_ And ((strInvoiceNum_ <> "") Or (datInvoiceDate_ <> 0)) Then
        '    SetSplitDocInfo strInvoiceNum_, datInvoiceDate_, datDueDate_, _
        ''        strTerms_, strImageFiles_
        'End If
        mstrImportKey = strImportKey_

    End Sub

    '$Description Update a Trx with new number and amount.

    Public Sub ImportUpdateNumAmt(ByVal strNumber_ As String, ByVal blnFake_ As Boolean, ByVal curAmount_ As Decimal)

        'Can change from fake to real, but not the reverse.
        If mblnFake Then
            mblnFake = blnFake_
        End If
        mblnAutoGenerated = False
        mstrNumber = strNumber_
        AdjustSplitsProportionally(curAmount_)

    End Sub

    '$Description Update a generated Trx with new amount, and make it non-generated.

    Public Sub ImportUpdateAmount(ByVal blnFake_ As Boolean, ByVal curAmount_ As Decimal)

        'Can change from fake to real, but not the reverse.
        If mblnFake Then
            mblnFake = blnFake_
        End If
        mblnAutoGenerated = False
        AdjustSplitsProportionally(curAmount_)

    End Sub

    '$Description Adjust split amounts to add up to a new total amount
    '   but retain the same proportions relative to each other. Does nothing
    '   if the Trx amount doesn't change, and assigns the entire amount to one
    '   split if either new or old amount is zero.
    '   Sets Trx amount to curNewAmount.

    Private Sub AdjustSplitsProportionally(ByVal curNewAmount As Decimal)
        Dim dblRatio As Double
        Dim curRemainder As Decimal
        Dim objSplit As Split_Renamed
        Dim lngSplit As Integer
        Dim curThisSplit As Decimal

        If mlngType <> TrxType.glngTRXTYP_NORMAL Then
            gRaiseError("AdjustSplitsProportionally used for wrong transaction type")
        End If
        If curNewAmount = mcurAmount Then
            Exit Sub
        End If
        'The proportional distribution algorithm breaks if either amount is zero.
        If curNewAmount = 0 Or mcurAmount = 0 Then
            lngSplit = 0
            For Each objSplit In mcolSplits
                lngSplit = lngSplit + 1
                If lngSplit = mcolSplits.Count() Then
                    objSplit.AdjustAmount(curNewAmount)
                    mcurAmount = curNewAmount
                Else
                    objSplit.AdjustAmount(0D)
                End If
            Next
            Exit Sub
        End If
        'Use proportional distribution.
        dblRatio = curNewAmount / mcurAmount
        curRemainder = curNewAmount
        lngSplit = 0
        mcurAmount = 0
        For Each objSplit In mcolSplits
            lngSplit = lngSplit + 1
            If lngSplit = mcolSplits.Count() Then
                objSplit.AdjustAmount(curRemainder)
                mcurAmount = mcurAmount + curRemainder
            Else
                curThisSplit = System.Math.Round(objSplit.curAmount * dblRatio, 2)
                objSplit.AdjustAmount(curThisSplit)
                curRemainder = curRemainder - objSplit.curAmount
                mcurAmount = mcurAmount + curThisSplit
            End If
        Next objSplit
    End Sub

    '$Description Add a new split to a Trx and subtract that amount from another
    'split in the same Trx. Normally both splits have the same PO# and this operation
    'represents applying an invoice to an open purchase order, but this routine
    'does not check the PO#.

    Public Sub ImportUpdatePurchaseOrder(ByVal objPOSplit As Split_Renamed, ByVal objImportedSplit As Split_Renamed)

        'A split with a PO# represents part of a purchase order due on that date.
        'If the split has no invoice number it represents a part of that purchase
        'order date that hasn't been matched to an invoice. If the split has an
        'invoice number it represents an invoice matched to that purchase order.
        'There should be only one split for a particular PO# and no invoice number
        'on a particular date, representing the uninvoiced portion of the purchase
        'order due on that date.
        'All splits related to the same purchase order and due on the same date
        'must belong to the same Trx, or Trx import will not divide the unreceived
        'portion of the purchase order correctly when applying invoices.
        With objImportedSplit
            objPOSplit.AdjustAmount(objPOSplit.curAmount - .curAmount)
            mcurAmount = mcurAmount - .curAmount
            AddSplit(.strMemo, .strCategoryKey, .strPONumber, .strInvoiceNum, .datInvoiceDate, .datDueDate, .strTerms, objPOSplit.strBudgetKey, .curAmount, .strImageFiles)
        End With

    End Sub

    Private Sub SetSplitDocInfo(ByVal strPONumber_ As String, ByVal strInvoiceNum_ As String, ByVal datInvoiceDate_ As Date, ByVal datDueDate_ As Date, ByVal strTerms_ As String, ByVal strImageFiles_ As String)
        Dim objSplit As Split_Renamed
        For Each objSplit In mcolSplits
            With objSplit
                .strPONumber = strPONumber_
                .strInvoiceNum = strInvoiceNum_
                .datInvoiceDate = datInvoiceDate_
                .datDueDate = datDueDate_
                .strTerms = strTerms_
                .strImageFiles = strImageFiles_
            End With
        Next objSplit
    End Sub

    Public Sub SetSortKey()
        Dim strInvNum As String = ""
        Dim objFirstSplit As Split_Renamed
        If mlngType = TrxType.glngTRXTYP_NORMAL Then
            objFirstSplit = mcolSplits.Item(1)
            strInvNum = objFirstSplit.strInvoiceNum
        End If
        mstrSortKey = mdatDate.ToString("yyyyMMdd") & IIf(mcurAmount > 0, "C", "D") & Mid("ZYX", mlngType + 1, 1) & _
            Left(mstrNumber & "          ", 10) & Left(mstrDescription & "                    ", 20) & Left(strInvNum & "                ", 16)
    End Sub

    '$Description Set mcurAmount for a budget Trx. Called whenever
    '   mcurBudgetApplied or mcurBudgetLimit changes.

    Private Sub SetAmountForBudget(ByVal datOldestEnd As Date)
        If System.Math.Abs(mcurBudgetApplied) > System.Math.Abs(mcurBudgetLimit) Or mdatBudgetEnds < datOldestEnd Then
            mcurAmount = 0
        Else
            mcurAmount = mcurBudgetLimit - mcurBudgetApplied
        End If
    End Sub

    '$Description Used only by Register.SetTrxStatus().

    Public Sub SetStatus(ByVal lngNewStatus As TrxStatus)
        mlngStatus = lngNewStatus
    End Sub

    Public Sub SetDate(ByVal datNewDate As Date)
        mdatDate = datNewDate
    End Sub

    '$Description Used only by TrxForm.cmdDivideTrx_Click()

    Public Sub ClearRepeat()
        mintRepeatSeq = 0
        mstrRepeatKey = ""
    End Sub

    Public Sub SetAmount(ByVal curNewAmount As Decimal)
        mcurAmount = curNewAmount
    End Sub

    '$Description Called only by Register.lngFixBalances().

    Public Sub SetBalance(ByVal curNewBal As Decimal)
        mcurBalance = curNewBal
    End Sub

    '$Description Add a split to the Trx. Updates the overall Trx amount as well,
    '   but does not apply to budget because the budget Trx may not exist yet.
    '   This is the only valid way to modify the splits, or the Trx amount.

    Public Sub AddSplit(ByVal strMemo_ As String, ByVal strCategoryKey_ As String, ByVal strPONumber_ As String, ByVal strInvoiceNum_ As String, ByVal datInvoiceDate_ As Date, ByVal datDueDate_ As Date, ByVal strTerms_ As String, ByVal strBudgetKey_ As String, ByVal curAmount_ As Decimal, ByVal strImageFiles_ As String)

        Dim objSplit As Split_Renamed

        If mlngType <> TrxType.glngTRXTYP_NORMAL Then
            gRaiseError("Trx.AddSplit only allowed on normal transaction")
        End If

        objSplit = New Split_Renamed
        objSplit.Init(strMemo_, strCategoryKey_, strPONumber_, strInvoiceNum_, datInvoiceDate_, datDueDate_, strTerms_, strBudgetKey_, curAmount_, strImageFiles_)
        mcolSplits.Add(objSplit)
        mcurAmount = mcurAmount + curAmount_

    End Sub

    '$Description Like AddSplit(), but clones an existing split and returns the new split.

    Public Function objAddSplit(ByVal objSrcSplit As Split_Renamed) As Split_Renamed
        Dim objDstSplit As Split_Renamed

        If mlngType <> TrxType.glngTRXTYP_NORMAL Then
            gRaiseError("Trx.AddSplit only allowed on normal transaction")
        End If

        objDstSplit = New Split_Renamed
        With objSrcSplit
            objDstSplit.Init(.strMemo, .strCategoryKey, .strPONumber, .strInvoiceNum, .datInvoiceDate, .datDueDate, .strTerms, .strBudgetKey, .curAmount, .strImageFiles)
            mcolSplits.Add(objDstSplit)
            mcurAmount = mcurAmount + .curAmount
        End With

        objAddSplit = objDstSplit
    End Function

    '$Description Apply the Split objects in this Trx to any matching budgets.
    '   Does nothing except for normal Trx.

    Public Sub ApplyToBudgets(ByVal objReg As Register)

        Dim objSplit As Split_Renamed
        Dim blnNoMatch As Boolean
        mblnAnyUnmatchedBudget = False
        If mlngType = TrxType.glngTRXTYP_NORMAL Then
            For Each objSplit In mcolSplits
                objSplit.ApplyToBudget(objReg, mdatDate, blnNoMatch)
                mblnAnyUnmatchedBudget = mblnAnyUnmatchedBudget Or blnNoMatch
            Next objSplit
        End If
    End Sub

    '$Description If Split objects for this Trx have been applied to any budgets,
    '   un-apply them from those budgets. No error or other reporting if Split objects
    '   not currently applied to budgets. Does nothing except for normal Trx.

    Public Sub UnApplyFromBudgets(ByVal objReg As Register)
        Dim objSplit As Split_Renamed

        If mlngType = TrxType.glngTRXTYP_NORMAL Then
            For Each objSplit In mcolSplits
                objSplit.UnApplyFromBudget(objReg)
            Next objSplit
        End If
    End Sub

    '$Description Apply a Split to the budget Trx which is ourself.
    '   Called only by Split.ApplyToBudget().

    Public Sub ApplyToThisBudget(ByVal objSplit As Split_Renamed, ByVal objReg As Register)

        If mlngType <> TrxType.glngTRXTYP_BUDGET Then
            gRaiseError("Trx.ApplyToThisBudget only allowed on budget transaction")
        End If

        mcolAppliedSplits.Add(objSplit)
        mcurBudgetApplied = mcurBudgetApplied + objSplit.curAmount
        SetAmountForBudget(objReg.datOldestBudgetEndAllowed)
        objReg.BudgetChanged_Renamed(Me)
    End Sub

    '$Description Un-apply a Split from the budget Trx which is ourself.
    '   Called only by Split.UnApplyFromBudget().

    Public Sub UnApplyFromThisBudget(ByVal objSplit As Split_Renamed, ByVal objReg As Register)

        Dim intIndex As Short
        Dim intDeleteIndex As Short
        Dim objEachSplit As Split_Renamed

        If mlngType <> TrxType.glngTRXTYP_BUDGET Then
            gRaiseError("Trx.UnApplyFromThisBudget only allowed on budget transaction")
        End If

        For Each objEachSplit In mcolAppliedSplits
            intIndex = intIndex + 1
            If objEachSplit Is objSplit Then
                intDeleteIndex = intIndex
                Exit For
            End If
        Next objEachSplit
        If intDeleteIndex > 0 Then
            mcolAppliedSplits.Remove(intDeleteIndex)
        Else
            gRaiseError("Could not find split in Trx.UnApplyFromThisBudget")
        End If

        mcurBudgetApplied = mcurBudgetApplied - objSplit.curAmount
        SetAmountForBudget(objReg.datOldestBudgetEndAllowed)
        objReg.BudgetChanged_Renamed(Me)
    End Sub

    '$Description Un-apply all splits applied to this budget Trx. Must be done
    '   for any budget being deleted from the register. Does nothing if this Trx
    '   is not a budget.

    Public Sub DestroyThisBudget()
        Dim objSplit As Split_Renamed
        If mlngType = TrxType.glngTRXTYP_BUDGET Then
            For Each objSplit In mcolAppliedSplits
                objSplit.ClearBudgetReference()
            Next objSplit
            'UPGRADE_NOTE: Object mcolAppliedSplits may not be destroyed until it is garbage collected. Click for more: 'ms-help://MS.VSCC.v90/dv_commoner/local/redirect.htm?keyword="6E35BFF6-CD74-4B09-9689-3E1A43DF8969"'
            mcolAppliedSplits = Nothing
        End If
    End Sub

    Public Sub ClearThisBudget()
        If mlngType = TrxType.glngTRXTYP_BUDGET Then
            mcurBudgetApplied = 0
            mcolAppliedSplits = New Collection
        End If
    End Sub

    '$Description Determine if this Trx is a match to search criteria.
    '$Param lngSearchField Which Trx data to search.
    '$Param strSearchFor What you are searching for. For category searches
    '   is the category key, not the text, and the search succeeds if any
    '   Split for the Trx has this category key.
    '$Param lngSearchType What kind of comparison to do. Ignored for category
    '   searches, which are always for equality.
    '$Param curMatchAmount The dollar amount of the item matched. Is the sum
    '   of matched split amounts for glngTRXSFL_CATKEY searches, otherwise
    '   the trx amount.
    '$Returns True iff the Trx is a match.

    Public Function blnIsSearchMatch(ByVal lngSearchField As TrxSearchField, ByVal strSearchFor As String, ByVal lngSearchType As TrxSearchType, ByRef curMatchAmount As Decimal) As Boolean

        Dim objSplit As Split_Renamed
        Dim strTrxData As String = ""
        Dim blnAnySplitsMatch As Boolean
        Dim blnThisSplitMatches As Boolean
        Dim strCatName As String

        blnIsSearchMatch = False
        curMatchAmount = 0

        Select Case lngSearchField
            Case TrxSearchField.glngTRXSFL_CATKEY
                'This is a special case, so we always exit the
                'function from this case.
                If mlngType = TrxType.glngTRXTYP_NORMAL Then
                    'Always check all splits because there may be multiple matches
                    'and we must return the total dollars matched.
                    blnAnySplitsMatch = False
                    For Each objSplit In mcolSplits
                        blnThisSplitMatches = False
                        If lngSearchType = TrxSearchType.glngTRXSTP_EQUAL Then
                            blnThisSplitMatches = (objSplit.strCategoryKey = strSearchFor)
                        Else
                            strCatName = gobjCategories.strKeyToValue1(objSplit.strCategoryKey)
                            blnThisSplitMatches = (Left(strCatName, Len(strSearchFor) + 1) = (strSearchFor & ":")) Or (strCatName = strSearchFor)
                        End If
                        If blnThisSplitMatches Then
                            curMatchAmount = curMatchAmount + objSplit.curAmount
                            blnAnySplitsMatch = True
                        End If
                    Next objSplit
                    If blnAnySplitsMatch Then
                        blnIsSearchMatch = True
                        Exit Function
                    End If
                End If
                Exit Function
            Case TrxSearchField.glngTRXSFL_INVNUM
                'This is a special case, so we always exit the
                'function from this case.
                If mlngType = TrxType.glngTRXTYP_NORMAL Then
                    'Always check all splits because there may be multiple matches
                    'and we must return the total dollars matched.
                    blnAnySplitsMatch = False
                    For Each objSplit In mcolSplits
                        blnThisSplitMatches = blnIsStringMatch(lngSearchType, (objSplit.strInvoiceNum), strSearchFor)
                        If blnThisSplitMatches Then
                            curMatchAmount = curMatchAmount + objSplit.curAmount
                            blnAnySplitsMatch = True
                        End If
                    Next objSplit
                    If blnAnySplitsMatch Then
                        blnIsSearchMatch = True
                        Exit Function
                    End If
                End If
                Exit Function
            Case TrxSearchField.glngTRXSFL_PONUMBER
                'This is a special case, so we always exit the
                'function from this case.
                If mlngType = TrxType.glngTRXTYP_NORMAL Then
                    'Always check all splits because there may be multiple matches
                    'and we must return the total dollars matched.
                    blnAnySplitsMatch = False
                    For Each objSplit In mcolSplits
                        blnThisSplitMatches = blnIsStringMatch(lngSearchType, (objSplit.strPONumber), strSearchFor)
                        If blnThisSplitMatches Then
                            curMatchAmount = curMatchAmount + objSplit.curAmount
                            blnAnySplitsMatch = True
                        End If
                    Next objSplit
                    If blnAnySplitsMatch Then
                        blnIsSearchMatch = True
                        Exit Function
                    End If
                End If
                Exit Function
            Case TrxSearchField.glngTRXSFL_DESCR
                strTrxData = mstrDescription
            Case TrxSearchField.glngTRXSFL_NUMBER
                strTrxData = mstrNumber
            Case TrxSearchField.glngTRXSFL_AMOUNT
                strTrxData = gstrFormatCurrency(mcurAmount)
            Case TrxSearchField.glngTRXSFL_MEMO
                strTrxData = mstrMemo
            Case Else
                gRaiseError("Unrecognized field in Trx.blnIsSearchMatch")
        End Select

        curMatchAmount = mcurAmount
        blnIsSearchMatch = blnIsStringMatch(lngSearchType, strTrxData, strSearchFor)

    End Function

    Private Function blnIsStringMatch(ByVal lngSearchType As TrxSearchType, ByRef strTrxData As String, ByRef strSearchFor As String) As Boolean

        Select Case lngSearchType
            Case TrxSearchType.glngTRXSTP_EQUAL
                blnIsStringMatch = (StrComp(strTrxData, strSearchFor, CompareMethod.Text) = 0)
            Case TrxSearchType.glngTRXSTP_STARTS
                blnIsStringMatch = (StrComp(Left(strTrxData, Len(strSearchFor)), strSearchFor, CompareMethod.Text) = 0)
            Case TrxSearchType.glngTRXSTP_CONTAINS
                blnIsStringMatch = (InStr(1, strTrxData, strSearchFor, CompareMethod.Text) > 0)
            Case Else
                gRaiseError("Unrecognized search type in Trx.blnIsStringMatch")
        End Select

    End Function

    '$Description Check for validation errors for Register.Validate().

    Public Sub Validate(ByVal objReg As Register, ByVal lngIndex As Integer)
        Dim objRepeatTrx As Trx
        If mstrSortKey = "" Then
            objReg.ValidationError_Renamed(lngIndex, "Missing sort key")
        End If
        If mdatDate = System.DateTime.FromOADate(0) Then
            objReg.ValidationError_Renamed(lngIndex, "Missing date")
        End If
        If mstrRepeatKey <> "" Then
            If mintRepeatSeq = 0 Then
                objReg.ValidationError_Renamed(lngIndex, "Repeat key has no repeat seq")
            End If
            objRepeatTrx = objReg.objRepeatTrx(mstrRepeatKey, mintRepeatSeq)
            If Not objRepeatTrx Is Me Then
                objReg.ValidationError_Renamed(lngIndex, "objRepeatTrx() returned wrong Trx")
            End If
        Else
            If mintRepeatSeq <> 0 Then
                objReg.ValidationError_Renamed(lngIndex, "Repeat seq should be zero")
            End If
        End If
        Select Case mlngType
            Case TrxType.glngTRXTYP_NORMAL
                ValidateNormal(objReg, lngIndex)
            Case TrxType.glngTRXTYP_BUDGET
                ValidateBudget(objReg, lngIndex)
            Case TrxType.glngTRXTYP_TRANSFER
                ValidateTransfer(objReg, lngIndex)
            Case Else
                objReg.ValidationError_Renamed(lngIndex, "Invalid trx type")
        End Select
    End Sub

    Private Sub ValidateNormal(ByVal objReg As Register, ByVal lngIndex As Integer)
        Dim objSplit As Split_Renamed
        Dim curTotal As Decimal
        If mcolSplits Is Nothing Then
            objReg.ValidationError_Renamed(lngIndex, "Missing split collection")
        Else
            curTotal = 0
            For Each objSplit In mcolSplits
                curTotal = curTotal + objSplit.curAmount
                If Not objSplit.objBudget Is Nothing Then
                    If objSplit.objBudget.lngType <> TrxType.glngTRXTYP_BUDGET Then
                        objReg.ValidationError_Renamed(lngIndex, "Split applied to non-budget trx")
                    End If
                    If objSplit.strBudgetKey = "" Then
                        objReg.ValidationError_Renamed(lngIndex, "Split applied to budget trx has no budget key")
                    End If
                    If objSplit.strBudgetKey <> objSplit.objBudget.strBudgetKey Then
                        objReg.ValidationError_Renamed(lngIndex, "Split applied to budget trx has wrong budget key")
                    End If
                End If
            Next objSplit
            If curTotal <> mcurAmount Then
                objReg.ValidationError_Renamed(lngIndex, "Normal trx splits add up wrong")
            End If
        End If
        If mblnFake Then
            If mstrImportKey <> "" Then
                objReg.ValidationError_Renamed(lngIndex, "Normal trx cannot have import key if it is fake")
            End If
            If mlngStatus <> TrxStatus.glngTRXSTS_UNREC Then
                objReg.ValidationError_Renamed(lngIndex, "Normal trx must be unreconciled if it is fake")
            End If
        End If
        If mstrBudgetKey <> "" Then
            objReg.ValidationError_Renamed(lngIndex, "Normal trx cannot have budget key")
        End If
        If mcurBudgetLimit <> 0 Then
            objReg.ValidationError_Renamed(lngIndex, "Normal trx cannot have budget limit")
        End If
        If mcurBudgetApplied <> 0 Then
            objReg.ValidationError_Renamed(lngIndex, "Normal trx cannot have budget applied")
        End If
        If Not mcolAppliedSplits Is Nothing Then
            objReg.ValidationError_Renamed(lngIndex, "Normal trx cannot have applied splits collection")
        End If
        If mstrTransferKey <> "" Then
            objReg.ValidationError_Renamed(lngIndex, "Normal trx cannot have transfer key")
        End If
        If mcurTransferAmount <> 0 Then
            objReg.ValidationError_Renamed(lngIndex, "Normal trx cannot have transfer amount")
        End If
    End Sub

    Private Sub ValidateBudget(ByVal objReg As Register, ByVal lngIndex As Integer)
        Dim objSplit As Split_Renamed
        Dim curTotal As Decimal
        If mstrBudgetKey = "" Then
            objReg.ValidationError_Renamed(lngIndex, "Budget trx requires budget key")
            Exit Sub
        End If
        If mcolAppliedSplits Is Nothing Then
            objReg.ValidationError_Renamed(lngIndex, "Missing applied split collection")
        Else
            curTotal = 0
            For Each objSplit In mcolAppliedSplits
                curTotal = curTotal + objSplit.curAmount
                If Not objSplit.objBudget Is Me Then
                    objReg.ValidationError_Renamed(lngIndex, "Split applied to budget trx has wrong objBudget")
                End If
                If objSplit.strBudgetKey <> mstrBudgetKey Then
                    objReg.ValidationError_Renamed(lngIndex, "Split applied to budget trx has wrong budget key")
                End If
            Next objSplit
            If curTotal <> mcurBudgetApplied Then
                objReg.ValidationError_Renamed(lngIndex, "Budget trx applied splits add up wrong")
            End If
        End If
        If mstrTransferKey <> "" Then
            objReg.ValidationError_Renamed(lngIndex, "Budget trx cannot have transfer key")
        End If
        If mcurTransferAmount <> 0 Then
            objReg.ValidationError_Renamed(lngIndex, "Budget trx cannot have transfer amount")
        End If
        If Not mblnFake Then
            objReg.ValidationError_Renamed(lngIndex, "Budget trx must be fake")
        End If
        If Not mcolSplits Is Nothing Then
            objReg.ValidationError_Renamed(lngIndex, "Budget trx cannot have split collection")
        End If
    End Sub

    Private Sub ValidateTransfer(ByVal objReg As Register, ByVal lngIndex As Integer)
        If mstrTransferKey = "" Then
            objReg.ValidationError_Renamed(lngIndex, "Transfer trx requires transfer key")
        End If
        If mstrTransferKey = objReg.strRegisterKey Then
            objReg.ValidationError_Renamed(lngIndex, "Transfer trx cannot transfer to same register")
        End If
        If Not mcolSplits Is Nothing Then
            objReg.ValidationError_Renamed(lngIndex, "Transfer trx cannot have split collection")
        End If
        If mstrBudgetKey <> "" Then
            objReg.ValidationError_Renamed(lngIndex, "Transfer trx cannot have budget key")
        End If
        If mcurBudgetLimit <> 0 Then
            objReg.ValidationError_Renamed(lngIndex, "Transfer trx cannot have budget limit")
        End If
        If mcurBudgetApplied <> 0 Then
            objReg.ValidationError_Renamed(lngIndex, "Transfer trx cannot have budget applied")
        End If
        If Not mcolAppliedSplits Is Nothing Then
            objReg.ValidationError_Renamed(lngIndex, "Transfer trx cannot have applied splits collection")
        End If
        If mstrImportKey <> "" Then
            objReg.ValidationError_Renamed(lngIndex, "Transfer trx cannot have import key")
        End If
    End Sub

    Public Function objClone(ByVal objReg As Register) As Trx
        Dim objNew As Trx
        objNew = New Trx
        Select Case mlngType
            Case TrxType.glngTRXTYP_NORMAL
                CopyNormal(objNew, objReg)
                CopySplits(objNew)
            Case TrxType.glngTRXTYP_BUDGET
                CopyBudget(objNew, objReg)
            Case TrxType.glngTRXTYP_TRANSFER
                CopyTransfer(objNew, objReg)
            Case Else
                gRaiseError("Unsupported Trx type")
        End Select
        objClone = objNew
    End Function

    Public Sub CopyNormal(ByVal objDstTrx As Trx, ByVal objReg As Register)
        objDstTrx.NewStartNormal(objReg, Me)
    End Sub

    Public Sub CopySplits(ByVal objDstTrx As Trx)
        Dim objSrcSplit As Split_Renamed
        For Each objSrcSplit In mcolSplits
            objDstTrx.objAddSplit(objSrcSplit)
        Next objSrcSplit
    End Sub

    Public Sub CopyBudget(ByVal objDstTrx As Trx, ByVal objReg As Register)
        objDstTrx.NewStartBudget(objReg, mdatDate, mstrDescription, mstrMemo, mblnAwaitingReview, mblnAutoGenerated, mintRepeatSeq, mstrRepeatKey, mcurBudgetLimit, mdatBudgetEnds, mstrBudgetKey)
        objDstTrx.SetAmount(mcurAmount)
    End Sub

    Public Sub CopyTransfer(ByVal objDstTrx As Trx, ByVal objReg As Register)
        objDstTrx.NewStartTransfer(objReg, mdatDate, mstrDescription, mstrMemo, mblnFake, mblnAwaitingReview, mblnAutoGenerated, mintRepeatSeq, mstrRepeatKey, mstrTransferKey, mcurTransferAmount)
    End Sub
End Class