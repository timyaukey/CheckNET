<?xml version="1.0"?>
<doc>
<assembly>
<name>
Willowsoft.CheckBook.Lib
</name>
</assembly>
<members>
<member name="T:Willowsoft.CheckBook.Lib.My.Resources.Resources">
<summary>
  A strongly-typed resource class, for looking up localized strings, etc.
</summary>
</member>
<member name="P:Willowsoft.CheckBook.Lib.My.Resources.Resources.ResourceManager">
<summary>
  Returns the cached ResourceManager instance used by this class.
</summary>
</member>
<member name="P:Willowsoft.CheckBook.Lib.My.Resources.Resources.Culture">
<summary>
  Overrides the current thread's CurrentUICulture property for all
  resource lookups using this strongly typed resource class.
</summary>
</member>
<member name="T:Willowsoft.CheckBook.Lib.Account">
 <summary>
 Represents one general ledger account and all the transactions in it,
 like a checking account or a loan account. The most important member
 is Registers, which is a collection of the Register objects containing
 the transactions in this account. Most commonly there is one register
 per account.
 </summary>
</member>
<member name="F:Willowsoft.CheckBook.Lib.CategoryTranslator.TypeKey">
 <summary>
 To add a new category type, define a constant here and add code to the following places:
 1) CategoryTranslator.TranslateType().
 2) CategoryEditorForm.blnShowDialog().
 3) TrialBalanceForm.btnIncomeExpenseStatement_Click().
 4) CategoryGroupManager.strGetGroupTitle().
 </summary>
</member>
<member name="T:Willowsoft.CheckBook.Lib.LineStringTranslator`1">
 <summary>
 A StringTranslator that loads its content from a text file, 
 one element per line of that file after skipping the first line.
 </summary>
 <typeparam name="TElement"></typeparam>
</member>
<member name="T:Willowsoft.CheckBook.Lib.Company">
 <summary>
 The core class of the object model. One instance contains all the data objects
 used by a company, including the list of general ledger accounts, and a bunch
 of other non-transactional definition data such as the category list.
 The simplest usage is to create an instance passing the path to the data file
 folder, and then call Load() to load all the accounts and everything else.
 You do not HAVE to call methods that check for files being in use, or authenticate
 the user.
 </summary>
</member>
<member name="M:Willowsoft.CheckBook.Lib.CompanyLoader.Load(Willowsoft.CheckBook.Lib.Company,System.Action{Willowsoft.CheckBook.Lib.Account},System.Func{Willowsoft.CheckBook.Lib.Company,Willowsoft.CheckBook.Lib.CompanyLoadError})">
 <summary>
 Load all Account objects and other objects belonging to a Company, after
 authenticating the user if the Company requires authentication to access it.
 </summary>
 <param name="objCompany">The Company to load.</param>
 <param name="showAccount">
 This delegate is called every time the CompanyLoader switches to working
 on a different Account. Will be called multiple times for each Account,
 as CompanyLoader goes through different stages of loading the Accounts.
 May also be called with Null/Nothing, indicating that no particular
 Account is in the process of being loaded. The method pointed to by this
 delegate can listen to the Account.LoadStatus event of the Account passed
 to be notified when things happen during the loading process. This
 delegate does not have to do anything - it is purely to allow the UI
 to show some kind of status display.
 </param>
 <param name="authenticator">
 This delegate is called to authenticate the user. Must return Null/Nothing
 if the user successfully authenticates, or no authentication is required
 for the Company. Otherwise returns an object subclassing CompanyLoadError, 
 whose type indicates the specific problem encountered.
 Uses Company.SecData.blnNoFile to determine if authentication is 
 required, and Company.SecData.blnAuthenticate() to authenticate 
 user name and password if that is required.
 </param>
 <returns></returns>
</member>
<member name="T:Willowsoft.CheckBook.Lib.RepeatSummarizer">
 <summary>
 Compile a summary of the usage of each repeat key.
 Used to create the StringTranslator for all those keys.
 </summary>
 <remarks></remarks>
</member>
<member name="M:Willowsoft.CheckBook.Lib.RepeatSummarizer.Define(System.String,System.String,System.Boolean)">
 <summary>
 Must be called for every BaseTrx that is part of a repeat sequence,
 and for each BaseTrx generator. Must be called for the generator last,
 so the name in the generator is the one used.
 </summary>
 <param name="key"></param>
 <param name="name"></param>
 <param name="fromGenerator"></param>
 <remarks></remarks>
</member>
<member name="M:Willowsoft.CheckBook.Lib.SearchUtilities.PruneSearchMatches(System.Collections.Generic.ICollection{Willowsoft.CheckBook.Lib.BankTrx},System.Collections.Generic.ICollection{Willowsoft.CheckBook.Lib.BankTrx}@,System.Boolean@,Willowsoft.CheckBook.Lib.SearchUtilities.PruneMatchesTrx)">
 <summary>
 Narrow down the results to one or more BaseTrx in colExactMatches if 
 there is anything in colExactMatches.
 </summary>
 <param name="colExactMatches"></param>
 <param name="colMatches"></param>
 <param name="blnExactMatch"></param>
 <param name="blnTrxPruner"></param>
 <remarks></remarks>
</member>
<member name="T:Willowsoft.CheckBook.Lib.SimpleStringTranslator">
 <summary>
 A LineStringTranslator that parses each line into the three parts of a StringTransElement.
 The first character of each line is the separator character for that line,
 and must appear two more times in the line. The substring between the first
 and second occurences is the key string, between the second and third
 occurences is the first value string, and after the third occurence is
 the second value string.
 </summary>
</member>
<member name="T:Willowsoft.CheckBook.Lib.Register">
 <summary>
 A transaction register, which is a list of BaseTrx objects from one Account and
 a running balance of those transactions. Use .GetTrx() to access those transactions.
 The running balance is computed from scratch each time it is loaded.
 Any transactions which are transfers to or from other registers must have those
 registers loaded as well, which generally means all registers must be loaded.
 </summary>
</member>
<member name="M:Willowsoft.CheckBook.Lib.Register.MakeComparableCheckNumber(System.String)">
 <summary>
 Return the last 4 digits of a check number.
 Used to create a check number to compare to for import matching,
 because some bank systems only give the last 4 digits of the check number.
 </summary>
 <param name="strInput"></param>
 <returns></returns>
</member>
<member name="T:Willowsoft.CheckBook.Lib.Security">
 <summary>
 Authentication and authorization tools.
 Use of these tools is voluntary. This system may be used without actually 
 authenticating the user or checking their authorization.
 </summary>
</member>
<member name="T:Willowsoft.CheckBook.Lib.BudgetTrx">
 <summary>
 A BaseTrx subclass representing an amount of money set aside for some use.
 TrxSplit objects can reference a BudgetTrx, which causes the effective
 amount of the budget item used in running balance computations to be
 different than the nominal budget amount.
 </summary>
</member>
<member name="M:Willowsoft.CheckBook.Lib.BudgetTrx.PutPeriodDatesInCorrectOrder">
 <summary>
 Only needed to load old data files that have trx date
 equal to the ending date, not the starting date.
 This method can be removed after all old data files
 have been loaded and saved. Which might be hard to 
 determine, because a .ACT file will not be saved
 until there is actually a change in it.
 </summary>
</member>
<member name="M:Willowsoft.CheckBook.Lib.BudgetTrx.EarliestPossibleApplied">
 <summary>
 Return the earliest BaseTrx in this register that could possibly
 be applied to this BudgetTrx. The returned object will always be non-nothing,
 but it may not be a BankTrx and it may not be applied to the Budget.
 It is merely the earliest that COULD be applied, based on the dates.
 The caller normally scans forward from here until they find a BaseTrx
 dated after mdatBudgetEnds.
 </summary>
 <returns></returns>
</member>
<member name="T:Willowsoft.CheckBook.Lib.BankTrx">
 <summary>
 A BaseTrx subclass representing a transaction that exists somewhere in the real
 world, like a credit card company or a bank. The actual amount of the transaction
 is represented by a collection of Split objects. Each BankTrx has at least
 one TrxSplit object.
 </summary>
</member>
<member name="T:Willowsoft.CheckBook.Lib.TrxSplit">
 <summary>
 Represents an amount of money associated with a BankTrx, plus
 attributes such as due date, category, invoice number, memo, etc.
 </summary>
</member>
<member name="T:Willowsoft.CheckBook.Lib.TransferTrx">
 <summary>
 A BaseTrx subclass representing a transfer between two Register objects
 in the same account.
 </summary>
</member>
<member name="T:Willowsoft.CheckBook.Lib.BaseTrx">
 <summary>
 Represents one transaction. Subclassed for different kinds of transactions.

 To create a transaction and add it to a Register, instantiate a BankTrx, BudgetTrx
 or TransferTrx and call NewStartNormal(), NewStartBudget() or NewStartTransfer() on
 that instance. For a BankTrx add at least one split with AddSplit(). Then call either
 Register.NewLoadEnd() or Register.NewAddEnd(): Call Register.NewLoadEnd() if you are in 
 the process of loading multiple BaseTrx into a Register from some external source, and will 
 finish that process by calling Register.LoadPostProcessing(). 
 Otherwise call Register.NewAddEnd(), which is what will typically happen if you are 
 adding to a Register which is already visible in the UI.
 
 To update an existing transaction, create a NormalTrxManager, BudgetTrxManager, 
 TransferTrxManager or ReplicaTrxManager and call UpdateStart() on that instance.
 Then make changes to members of .GetTrx of that instance. You can make changes to individual
 members directly, or remake the entire BaseTrx from scratch by calling something like 
 .GetTrx.UpdateStartNormal(). If you do call UpdateStartNormal(), always call
 .GetTrx.AddSplit() at least once. When you are done making changes to .GetTrx,
 finish by calling TrxManager.UpdateEnd().
 
 To delete a transaction, call either Register.Delete() or BaseTrx.Delete().

 The UI is not updated directly by the caller to these methods, rather it is
 updated indirectly by responding to events fired by the Register object as
 its methods are called and complete their tasks.
 </summary>
</member>
<member name="P:Willowsoft.CheckBook.Lib.BaseTrx.Amount">
 <summary>
 The face value amount of the transaction.
 </summary>
 <returns></returns>
</member>
<member name="P:Willowsoft.CheckBook.Lib.BaseTrx.BalanceChangeAmount">
 <summary>
 The amount this transaction will change the running balance in a register.
 We distinguish this from the face value of the transaction because the
 software may in the future treat some transactions as not affecting the balance.
 </summary>
 <returns></returns>
</member>
<member name="P:Willowsoft.CheckBook.Lib.BaseTrx.Balance">
 <summary>
 The register balance after adding this transaction.
 </summary>
 <returns></returns>
</member>
<member name="T:Willowsoft.CheckBook.Lib.TrxManager`1">
 <summary>
 A helper class to update a BaseTrx that is already in a Register.
 Create an instance of the TrxManager subclass appropriate to the BaseTrx subclass,
 passing to the constructor a BaseTrx that is already in the Register.
 Then call TrxManager.UpdateStart(), then modify any properties you want of that BaseTrx,
 then call TrxManager.UpdateEnd().
 This handles all the details of managing the Register, budget tracking for normal BaseTrx,
 logging, firing events, etc.
 NOTE: Once you call UpdateStart() you MUST call UpdateEnd() or the Register object
 will only be partly updated.
 NOTE: You CANNOT construct a new BaseTrx to use with this. It must be the existing
 BaseTrx in the Register you wish to update.
 </summary>
</member>
</members>
</doc>
